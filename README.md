# PINS-JavaBytecode-Compiler
A PINS to Java bytecode compiler, created as part of my undergraduate diploma 
thesis.

---

## 1. Description

This compiler is a part of my CS Undergraduate diploma thesis, in which
I attempt to expand the [PINS Compiler](https://github.com/LukaSveigl/PINS22-Compiler)
created as part of my Undergraduate course in **Compilers and Virtual machines**,
by changing the back-end compilation process to target the **Java Virtual Machine**,
instead of the educational PINS interpreter kindly provided by our professor.

---

## 2. Language specifications

The PINS programming language is a simple, general-purpose
programming language created for educational purposes. The specification for the
language can be found in [PINS-specification-SLO.pdf](PINS-specification-SLO.pdf), and the grammar
for the language can be found in [PINS-grammar.txt](PINS-grammar.txt). Some examples of PINS
programs can be found in [prg](prg).

---

## 3. Building and running

To build this project, simply import the project into your IDE of choice. The project has 
been known to work on atleast Java 17. The project does not use any external libraries, 
so no additional setup is required. In the future an OS-agnostic Makefile will be added.

To run this project, simply run the 'Compiler' class, which is the entry point of the
application. The compiler takes multiple arguments, which are described below:

```
Usage: java Compiler [options]...
    The compiler options are:
        --src-file-name=<path>      Path to the source file to be compiled.
        --dst-file-name=<path>      Path to the destination file where the 
                                    compiled bytecode will be written. If the destination
                                    file is not specified, the compiled bytecode will be
                                    written to a class file with the same path as the
                                    source file, but with the '.class' extension.
        --target-phase=<phase>      To run the project use the phase 'all'.
        --comp-method=<method>      One of: 'interp', 'compile'. 'interp' will run the 
                                    interpreter, 'compile' will compile the source file
                                    to the file specified by the --dst-file-name option.

Example:
    java Compiler --src-file-name=prg/program.pins --target-phase=all --comp-method=compile
```





---

## 4. The compiler

The compiler is split into multiple standard phases. Descriptions for most of them 
can be found in the repository for the original compiler, available here:
[PINS22-Compiler](https://github.com/LukaSveigl/PINS22-Compiler)

The phases that are different from the original compiler are described below:

### 4.1 Reference analysis

This phase is responsible for analysing which variables are supposed to be passed around
as references. This is done by analysing the AST and looking for the following constructs:
- Nested function calls
- Prefix expressions with the reference operator

This is done because PINS22 supports nested functions and pointers, which are not supported
in the Java Virtual Machine, thus needing to be emulated. This is done by passing around
arrays of size 1, which contain the value of the variable.

The phase is implemented in the 'refan' subdirectory of the 'phases' directory.

### 4.2 Bytecode generation

This phase is responsible for generating the IR code representing the JVM instructions. It
traverses the ASTs and generates the appropriate IR sequences for each AST node. The phase 
is implemented in the 'btcgen' subdirectory of the 'phases' directory.

### 4.3 Bytecode emission

This phase is responsible for converting the IR code generated by the previous phase into
the actual bytecode and writing it to a file. This is done by looping over the IR code
of the methods, converting it to a corresponding sequence of bytes and writing it to a file.

The phase is implemented in the 'btcemt' subdirectory of the 'phases' directory.

---

## 5. Performance

Work in progress.

---

## 6. Future work

Additional work planned for the future:
- [ ] Add a Makefile for OS-agnostic compilation.
- [ ] Add a more comprehensive test suite.
- [ ] Add a more comprehensive benchmark suite.
- [ ] Fix bugs relating to pointers and nested functions.